---
layout: post
title: 深入HTTP/3(3)---不那么boring的SSL
categories: Network
keywords: HTTP/3, QUIC
---

## 引言
从前一篇文章对于QUIC的浅述中我们了解到，QUIC的优化很大程度上是一种基于TLS流程的优化，由此也可见TLS对于QUIC的重要性，那么今天我们就来聊一聊QUIC-TLS。为了表述尽量没有歧义，我们先来规范下文章中各个术语的意义。本文目前既然已经提到了SSL，TLS这两个术语，我们不妨先来简短回顾下安全协议的发展史，这既可以帮我们理清两个术语的关系，也能帮助我们对这项技术的进化有一个简短的概念。

SSL(Secure Sockets Layer)协议本身是网景公司为了保证互联网上数据传输的安全性，在1994年设计的一套协议。这套协议在当时被广泛使用在各大浏览器上，但SSL协议的每个版本的安全性都非常堪忧，从1994年到1995年连续迭代了3个大版本，现在大家最耳熟能详的应该就是SSLv3.0了。可惜SSLv3.0也没有逃脱更迭的厄运，由于硬件算力的迭代，大量SSLv3.0中广泛使用的加密算法不再安全，并且SSL交互设计也存在不安全之处，1999年，IETF正式介入安全协议的设计及开发，并推出了TLS(Transport Layer Security)协议的第一个版本TLS1.0，随后TLS协议的发展开始变得迟缓，在2006年IETF组织推出了TLS1.1，并在2008年再次发布了TLS1.2，两个版本都是针对一些握手交互过程中的细节的安全提升，握手流程其实是没有大的变化的。直到2013年，google在推出gquic的同时，也推出了其自己设计的安全交互流程quic-crypto，quic-crypto是一次交互流程的重大创新，也以此成为了TLS1.3的前身。TLS1.3从某种意义上来说，应该被称作TLS2.0，因为其革新力度非常大，当然这也导致其标准化流程非常长，TLS1.3的标准化整整历经了4年，直到2018年才正式成为RFC。而TLS1.3本身也成为了IETF-QUIC的安全交互技术的基础，所以这条时间线里也揉杂了QUIC-TLS的设计历程，我们来简单理一下：

![](/images/self-drawn/h3-3-ssl/f1.png)

当然DTLS等相关安全技术的进化也融合在这条时间线中，限于篇幅问题，这里暂时不表，后面有相关技术分析时会明确的做说明。说了这么多废话，我们现在来正式标准化一下我们的名词：
1. SSL，TLS：在本文中都指安全传输协议，后续的文章中只会使用TLS作为相关技术的代名词
2. QUIC-crypto：Google quic中使用的握手流程，本文不对其进行具体分析
3. QUIC-TLS：本文指IETF-QUIC使用的安全交互流程，即RFC9001中标准化的流程，也是本文详细描述的重点。
4. PTO：全称为Probe Timeout，定义于RFC9002中，留待下一篇文章来对其进行详细分析，本文将其理解成一个通信端设置的针对报文的超时重传的时间即可。
5. DTLS：全称为Datagram Transport Layer Security，即面向报文的TLS协议，限于篇幅的问题，本文并不详细对其分析，而DTLS中存在有很多和QUIC-TLS类似思路的设计，感兴趣的同学可以参见RFC9147﻿

在引言的最后，再来呼应一下文章标题，“make infrastructure boring”是Google一直以来的口号，而BoringSSL这个开源产品则是他们在安全通信领域的行动，而文章的标题既然叫“不那么Boring的SSL”，除了蹭一蹭BoringSSL和OpenSSL这些著名的SSL开源项目的热度之外，也是想给文章制造一点悬念：Boring往往意味着相关技术简单好用到了令人发指的地址，而QUIC到底遇见了什么问题，才让本身相对成熟的TLS协议用起来不再Boring？本文后续也将围绕这个话题展开，来看看QUIC-TLS设计中那些值得玩味的地方。

## 浅看TLS
本着由浅入深的思路，在开始介绍QUIC-TLS之前，我们也先浅析一下TLS，这也非常有助于我们后面对于QUIC-TLS的理解。TLS协议从某种程度上来说解决了几个哲学问题：你是谁？你怎么证明你是你？当然这些问题的答案还不足以保证整个通信流程的安全，我们还需要一种技术来保证中间人无法获取到我们的数据，这也就是我们相对比较熟悉的对称加密技术，比如AES，SM4等加密技术；而为了加密的数据也能证明通信一端的身份，我们引入了AEAD这种加密即认证的模式；为了协商出这种对称加密的密钥，TLS引入了非对称密钥交换技术，典型如ECDHE，RSA等密钥交换算法；为了身份管理的统一及身份的有效携带，TLS引入了数字证书技术，包括整个pki公钥体系及X509数字证书标准；为了数据的不可篡改，TLS引入了数字签名技术，典型如ECDSA，RSA等签名算法；为了各个阶段的加密密钥独立及签名流程的简洁，TLS引入了Hash算法，典型如SHA系列算法。

上述的各种机制在整个TLS协议中被抽象为两大块协议，一层是Handshake协议，负责核心密钥的交互及身份认证，一层是record协议，负责数据的安全，完整性及握手完成后数据的可信，而Handshake协议则坐落于Record协议之上，这也就形成了这样的协议栈：

![](/images/self-drawn/h3-3-ssl/f2.png)

用相对简洁的话来说就是，Handshake过程中的数据也依赖Record层来进行数据加密，而Record层加密的key则依赖Handshake层进行交互得到。这看似是个逻辑死锁，实际上是通过一个层层递进的状态机完成的，抛开繁琐的TLS状态机本身，这个流程基本可以用下图来表述：

![](/images/self-drawn/h3-3-ssl/f3.png)

至于TLS的初始阶段使用明文传输的数据，也并不违背这个流程，我们可以将其理解为TLS初始阶段对应一个值为空的key。而从上图中我们也可以看到，实现和虚线部分对应的两个阶段切换，必须有严格的先后顺序，如果发生乱序，一端是无法完成数据的解析的，所以TLS协议非常依赖底层传输协议来保证数据的有序到达，而这也是TLS的设计区别于DTLS和QUIC-TLS的最大根因之一。有了这部分知识储备，我们再来看TLS的握手(以TLS1.3的0-RTT交互场景为例)，就会清晰很多：

![](/images/self-drawn/h3-3-ssl/f4.png)

可以看到，"明文"，"()"，"{}"，"[]"对应的加密状态的切换，和上面的图的流程基本是一致的，而典型如EndOfEarlyData这种标示数据，就是用来通知对端的密钥状态切换的，这部分的理解对于我们后面理解QUIC-TLS的设计大有用处。

在这一章的最后，我们对TLS做一个简单总结：

![](/images/self-drawn/h3-3-ssl/f5.png)

而在使用层面来说，TLS通过一层安全的抽象，让应用层可以直接通过一个简单的SSL_read/SSL_write(以OpenSSL/BoringSSL为例)读写接口，就可以直接使用安全通信的能力，而完全不需要关注TLS握手，状态转换的细节。从这个角度来说，使用TLS已经足够Boring了，而从安全诉求上来说，本身QUIC-TLS和TLS是一致的，也不应该会有大的出入，那么又是什么让QUIC-TLS变得如此复杂呢？

## 深入QUIC-TLS的不同之处
在我们上一篇文章里，我们已经对QUIC建联进行了分析，为了保证QUIC建联的高效，QUIC将有序和安全融合在了一起，而我们知道，本身TLS是基于TCP设计的协议，两者之间有严格的分层，而TCP协议保证了所有数据都被成功且有序的传输到了对面，所以TLS便不需要再考虑丢包和乱序的问题。而QUIC-TLS则需要将两者合在一起考虑，回顾前文，我们知道QUIC为了不协商即可在第一个报文开始有序传输，引入了pkt number和每个帧的offset机制，并且两个标示均从0开始，然后由TLS来保证其安全性，细心的读者可能已经发现这其中逻辑的循环依赖了。

![](/images/self-drawn/h3-3-ssl/f6.png)

为了解开这个死循环，QUIC-TLS必须将安全层面的交互做更细粒度的拆分，才能够实现既安全又可靠的传输，因此在RFC9001中我们可以看到，QUIC的协议栈看起来会是这个样子：

![](/images/self-drawn/h3-3-ssl/f7.png)

这个图和前面TLS协议栈有点像，但又不那么像，我们已经知道，协议栈层层分层的效果就是上层协议生成的报文会按照payload的形式塞在其下一层的协议中，QUIC Packet Protection协议作为保护数据安全的协议，那么其职责和TLS Record是类似的，而QUIC Transport协议(保证QUIC可靠有序传输)这部分则和TCP类似，可以看到QUIC协议栈的下半部分是完全和TLS+TCP的协议栈相反的，这也就意味这QUIC-TLS的设计在底层上必然和TLS的设计不尽相同，我们来深入拆解一下。

### 以包为基本单位的加密策略
我们已经知道了record层的功能靠的是对称加密算法来保证安全，并用AEAD的加密模式来保证数据的可信，以一个典型的实例算法AES-128-GCM为例，AES-128表示对称加密算法为AES-128，GCM其对应的AEAD算法，AES-128-GCM加密拥有四个输入：(1) 待加密明文plaintext; (2) 加密的密钥key; (3) 加密的随机数Nonce; (4) 认证的关联数据Associate Data。其解密也基本一致，仅将明文换成加密后的密文ciphertext即可，对于Nonce这个值，在TLS中，由于本身不用考虑数据的有序传输，Nonce是通过client和server自己为每个record报文维护一个技术器来实现的，即Nonce从0开始，每收到一个对端的record报文自加1。

对于QUIC-TLS，在整个流程上大体也逃不开这一套机制，然而对于QUIC-TLS而言，由于安全和有序已经融合在了一起，我们每收到一个报文，需要先解密才知道报文是不是乱序，所以我们不能通过维护计数器的方式来实现自增Nonce的这个功能。怎么办呢？我们恰好看到有packet number这样一个单调自增的值(注意packet number的功能并不是为了作为Nonce，其具体的作用我们留到后面QUIC的丢包检测部分再深入分析)，非常适合作为Nonce，但packet number本身又是需要加密的，这要怎么处理呢？解决方案也不复杂，那就是packet number使用较为弱的加密模式，即最简单的ECB模式来加密，以AES-128-ECB为例，这种模式加/解密只需要两个输入：(1) 待加密明文plaintext/待解密的密文ciphertext; (2) 加密的密钥key。再次回顾之前关于TLS的状态转换的图，只要我们能按照这样的状态转换不断的更新key，我们就可以按照下面的流程去解开pkt number，并以此为基础进一步解密得到握手/应用层的信息（注意其中的步骤3，4并不一定有严格的顺序之分，因为QUIC的丢包检测等不仅是依赖pkt number，也依赖一些特殊的控制帧，关于这部分，我们留到后面关于QUIC的丢包检测的相关文章中进行分享）。

![](/images/self-drawn/h3-3-ssl/f8.png)

了解了这一步，我们也就明确了为什么QUIC在安全层面会选择以QUIC packet作为基本单位的原因。当然，一次QUIC-TLS握手过程中会有多个状态，也就是有多个不同加密的key，为了让QUIC的交互过程更清晰，QUIC也定了6中不同类型的Packet，用来对应6种状态，也就是6种加密的key:

![](/images/self-drawn/h3-3-ssl/f9.png)

其中Initial部分对应的则是TLS过程中明文传输的部分，这部分数据虽然在名义上也是加密了的，但其加密的key是一个写死在RFC里的，人人都知道的值，也就相当于明文传输了。这种做法倒不能说是多此一举，因为这确实也在某种程度上提升了攻击者的攻击成本，但它的确不能保证ClientHello这部分数据的安全，为此，QUIC-V2也准备引入Encrypt-ClientHello等安全技术来对这部分数据进行保护，这个我们在后文再慢慢分享。

这种区分了pkt type的包加密模式，让数据有了更清晰的状态转移标识。我们再来回头看一看TLS的状态转移图，可以看到，每次通知对端从key1切换到key2时，一定是会先发送一个用key1加密的通知消息(即TLS中的ChangeCipherSpec)，才会再去发key2加密的数据的，这样才能从理论上保证对端能够成功处理通知消息，完成key状态的变化。而在QUIC-TLS中，包的pkt type则成为了这样一个显式的通知状态转移的标识，比如对端开始响应Handshake包了，就说明状态就是要转移到Handshake状态了，而这也就让QUIC-TLS不再需要ChangeCipherSpec以及EndofEarlyData这一类的显式通知对端的机制，并且这对于握手过程的乱序处理有很大帮助。有了这些储备知识，我们再来深入看看QUIC-TLS握手的细节，就更容易把握其本质。

### 不严格的分层，带来更加严格的0-RTT使用限制
0-RTT功能的雏形来自于QUIC-crypto，并在TLS1.3中被正式标准化，也成为了一个TLS1.3非常吸引用户的点，然而该功能的使用条件却非常苛刻，首先，0-RTT依赖TLS的会话复用的成功，这也就意味着其使用流程必须存在着交互确认的机制，否则client初始阶段一股脑的发0-RTT数据过去，却又无法被server确认接收，那么这就是对信道资源的一种浪费，其次，0-RTT数据本身涉及到密钥状态的转换，那么也就需要为其设计相应的状态转换机制(及前文的EndOfEarlyData)，最后，0-RTT数据本身是不安全的，因为其完全不能避免重放攻击，只能依靠应用层协议自己保证幂等。

对于第一个问题，QUIC-TLS和TLS1.3并无太大差别，都是通过server的响应里的扩展来说明是否接收0-RTT数据的，而第二个问题前文我们也已经分析过，QUIC-TLS依靠包的显式加密等级，也不需要EndOfEarlyData这种机制来通知密钥状态需要转换。但到了问题3，要考虑的情况就会复杂很多，我们先从QUIC层面出发来看，我们知道QUIC通过STREAM类型的帧来承载应用层数据，但除了承载数据之外，QUIC也提供了诸如RESET_STREAM, STOP_SENDING这一类用于控制应用层数据传输的控制帧，而这些都是重放不安全的。那么在QUIC的角度上来看，除非你知道自己的应用层协议如何在操作QUIC的stream，并且有明确的能力去保证这些行为的重放安全，你才能去用这个能力，否则干脆将其束之高阁，RFC9001中对此也是提出了明确的建议。

而我们再站到HTTP/3的角度来看一下，之前的文章里我们也提到过，HTTP/3并不是QUIC+HTTP/2，而是将HTTP/2中流这部分的抽象交给了QUIC，然后在HTTP/3里去控制这些流。从这一点说，HTTP/3原生的符合了QUIC-TLS中对于0-RTT能力使用的要求，但我们仍有诸多问题需要考虑，因为QUIC本身是一个对于链接以及链接上的流有诸多可配置参数的协议。当client要开始传应用层数据的时候，往往就意味着底层的传输条件已经协商好了(而由于HTTP/3和QUIC的绑定关系，这些传输参数还包含着HTTP/3的一些语义)，而client传输0-RTT数据时，我们无法通过协商去获取这些参数，而只能通过之前的链接参数来继续传输，所以对于集群化的QUIC场景，保证集群内机器配置的一致性以及变更的兼容性，也是QUIC使用者需要注意的一大问题。

### QUIC-TLS握手，乱序带来的复杂度提升
我们先来看下RFC9001中对于QUIC-TLS的交互示意图：

![](/images/self-drawn/h3-3-ssl/f10.png)

仅从这个握手协议图来看，如果我们先简单的：(1)将init报文当ClientHello/ServerHello；(2) 0-RTT报文对应TLS的0-RTT数据；(3)HandShake数据对应ServerFinish/ClientFinish。那么这个握手流程似乎和TLS并没有什么不同，事实上仅从握手原理来看，也确实如此。然而当我们引入乱序的考虑之后，问题复杂度就要高出不少了，我们已经在前面分析过，TLS是依赖TCP的有序传输来保证状态(或者说当前加解密的key)的层层递进的，也正因为数据严格有序，TLS也只需要维护当前一个key就行。而到了QUIC-TLS这里，问题就不再如此简单了，我们可以分成两种典型情况来讨论

#### 下一阶段的包提前到来
这个问题虽然在QUIC-TLS握手过程中有共性，但也要分阶段来看，每个阶段也有每个阶段自己的问题特点，目前触发这个问题其实有好几种可能性：

1. client的0-RTT报文早于Init报文到来
2. Server的Handshake报文早于Init报文到来
3. Server的1-RTT报文早于Server的Handshake报文到来
4. client的1-RTT报文早于client的Handshake报文到来

对于第一种情况，其实解决方案非常简单，由于ClientHello本身并不会很大，并且在首包我们只会发1个0-RTT报文(因为并不知道server是否会接收0-RTT报文，所以先发一个尝试一下)，我们可以通过将QUIC包聚合在一个UDP包内发送(这是标准允许并且推荐的)来从根源上解决乱序的问题。然而后续的问题就较为复杂了，在情况2的条件下，由于服务端的证书可能比较大，Server的Handshake包也就会很大，光靠聚合Server的Init是不能满足要求的，试想一下，如果客户端对于乱序的情况选择全部缓存的策略的话，中间攻击人可以直接通过不断发送HandShake报文，来将客户端的缓存吃完的。而QUIC的巧妙之处也就在这里，协议层的耦合可以使得其他层次安全机制在当前层面也可以服用，还记得上一篇文章讲的放大攻击的防范吗？客户端握手完成前，服务端不允许发送3倍以上的数据，直到收到客户端的响应，客户端可以以此为标示来对这种场景防范。当然，从实现层面来讲，大部分实现者还是会选择直接丢弃这种乱序报文，因为维护这种缓存队列本身就是一个复杂的事。对此，RFC也有相应的建议，服务端实现握手过程中的数据有限次的早于PTO结束的重传，来加速握手的完成。

情况3和4从原理上来看，和情况2面临的问题似乎也没有很大差别，但其中涉及到的细节问题还是需要case by case的讨论，首先，在真实应用场景下，情况3却往往不存在，而其为什么不存在，则需要看情况4的问题，如果仅从TLS交互图来看，client的1-RTT数据早于client Handshake报文到来，server其实此时是有1-RTT的key的，可以完成数据的解密。但考虑这两种情况：(1) 在双向认证的场景下，此时client Handshake中携带的是client的身份数据，server不应该在身份验证完成前响应用层的数据，也就不应该在握手完成前，发送1-RTT的数据；(2) 在0-RTT场景下，首先我们知道，0-RTT数据对应的响应都是通过1-RTT报文携带的，但0-RTT数据本身由于安全问题，只能依靠应用层的幂等性来实现重放攻击的保护，在握手没有成功前，server无法确认是否收完了所有0-RTT数据，而没有全量数据的情况下应用层也无法确认是否数据是否是重放攻击，所以在握手完成前，服务端也不能直接响应0-RTT的报文。总的来说，出于应用层面的考虑，情况4有了更明确的限制，RFC9001则直接明确规定服务端不应当在握手完成前处理1-RTT报文，但至于本身UDP层面的缓存怎么实现，就交给实现者根据自己的网络情况去斟酌了。

#### 收到之前加密阶段的包
刚刚我们讨论的是如何处理新状态数据的问题，那么现在我们再看看如何维护老的状态的问题。从TLS的经验来看，似乎从直觉上来说我们并没有必要维护之前加密状态数据，而QUIC-TLS和TLS也类似，如果通信某一端成功进入了下个握手阶段，那么也意味着其已经收到了所有必要的握手消息，那么如果它再次之前阶段的数据，这些数据要么就是重传，要么就是攻击，似乎也没有处理的必要？的确，如果仅从握手来看，维护上一阶段的key是浪费的，但把0-RTT功能考虑进来，则就不一定了。对于client来说，正常情况下0-RTT数据的应当是早于client的Handshake报文发送的，但由于中间网络设备的不可控，0-RTT数据是可能晚于1-RTT数据到来的，如果server能维持0-RTT的加密状态，那么就可以避免这些乱序包的重传。而我们前面已经讨论过，0-RTT本身并不是一个很安全的机制，在QUIC-TLS中client应当在1-RTT密钥生成后马上将其废除，所以server也没有必要长时间维护0-RTT对应的加密状态，而对于具体维护的时间的选择，RFC9001建议了一种类似TCP Time_wait的方案，即server只需维护0-RTT密钥持续3个PTO的时间，确保乱序数据在网络中自然消亡，即可淘汰掉相关的密钥状态。

除了0-RTT的Key的处理，QUIC-TLS中还有一个Key Update的机制，用于在握手完成后，对当前状态的密钥进行更新，这个机制也面临着和乱序和新旧状态的key的维护的问题，但其原理和0-RTT是一致的，这里就不再赘述了。

## 小结，再看QUIC-TLS协议栈
至此，我们已经了解了QUIC-TLS是如何通过各种细节机制来保证其状态能成功层层演进了，我们不妨再回头看下图6中的QUIC-TLS的协议栈，可以看到，QUIC Packet Protection这部分通过维护当前阶段的key，以及显式加密等级的QUIC报文机制，可以清晰的得到明文的数据，而QUIC Transport这一层则提供了功能上相对独立的可靠传输机制。如此来看，上层TLS Handshake这部分就可以拆的很细而且实现功能上的独立了，出于工程上的懒人思维，也是对于安全稳定性的考量，现有的TLS能复用的当然要尽可能复用起来，所以我们可以看到QUIC-TLS里定义了如何去设计TLS的API，让其刚好能和底层的QUIC交互使用：

![](/images/self-drawn/h3-3-ssl/f11.png)

至此，本文差不多完成了对QUIC-TLS握手阶段的所有分析，可以看到，QUIC-TLS的设计中充斥着大量层间耦合的考虑，任何一个功能点，并不是简简单单满足诉求就行，既需要向上考虑上层应用协议，也需要向下考虑本身协议栈的适配。而这样的设计，充斥着QUIC协议栈的各个点，我想这也就是QUIC历经这么多年才终成标准的原因之一吧。

文章写到这里确实有点长了，感谢各位读者可以看到这里。本文对于QUIC-TLS中涉及的很多细节流程比如Head保护的算法，Retry token的加密等，都没有提及，但在个人的视角来看，这些都是相对独立，并且较为容易理解的功能，读者自行看RFC9001应该就可以理解了，如果大家有需要也可以留言，后面再出一期关于这些细节的总结性文章。

## 对于QUIC-TLS的展望
前文说了一圈QUIC-TLS和TLS的不同，反而到展望这里，QUIC-TLS倒是和TLS的的演进出奇的一致，当然这也是一个符合逻辑的结论，因为无论是QUIC-TLS还是TLS，终究都是在为用户的安全提供保障，而下一代的安全技术也往往都是在加解密等技术细节上发力，在我们肉眼可见的未来，我们也许可以在QUIC-V2看到这些技术的落地：

1. Encrypted ClientHello：这部分已经在前文讨论过，为了使QUIC的Init报文更加安全，我们可以通过公钥加密技术和带外公钥同步的方式，来实现首包的加密，感兴趣的读者可见[相关草案](https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-14)。
2. Certificate Compression：证书链过长一致是导致弱网环境握手成功率低的重要原因之一，而对证书进行有效压缩，会使交互数据大幅降低，提高握手成功率，感兴趣的读者可见[相关标准](https://datatracker.ietf.org/doc/html/rfc8879)。
3. Delegated Credential：公有云，混合云环境的安全性一直受到各种挑战，而私钥作为如此重要的数据，部署在公有云上也有很大的风险，通过对叶子证书签发短期的委派凭证，可以有效的减少攻击窗口，感兴趣的读者可见[相关标准](https://datatracker.ietf.org/doc/html/draft-ietf-tls-subcerts-15)。
4. 国密交互：在当前局势下，密码安全已经上升到了一个很高的高度，我们也在尝试将国密算法标准化到QUIC-TLS流程中，以满足合规性和安全性的诉求。

当然各种新兴技术是层出不穷的，我们也会持续不断的跟进，以保证相关产品的用户在享受良好网络体验的条件下，也能得到极致的安全保障。

## 最后带个货
最后的最后，看完技术分享，不如再来点产品分享及八卦时刻，OpenSSL确实是一个不可多得的开源届良心产品，但它在QUIC-TLS这个事情上确实搞的有点令人迷糊，很早前，Akamai的贡献者就针对QUIC-TLS的功能做了PR提交，但是OpenSSL一直以QUIC还没有标准化作为理由，不给予合并考虑，等到QUIC标准化了之后，OpenSSL官方社区又说自己不满足于只有QUIC-TLS的库的支持，要自己搞个QUIC的完整实现(包括s_client，s_server等测试客户端/服务端对于QUIC的支持)，虽然社区充斥着大量质疑的声音，但最终还是没能动摇他们的决心，当然这并不说明OpenSSL的抉择是错的，因为从OpenSSL组织的思考来看，OpenSSL不太满足于当前想一个简单的为QUIC提供TLS库的能力的角色，他们想更进一步转变成一个为产品提供QUIC库的角色，而目前的选择也是他们的必由之路。

当然他们的理想是远大的，而苦的是我这种OpenSSL重度用户，OpenSSL初期开源的PR其实在使用过程中还是有不少小问题，并且由于OpenSSL的不支持，大部分开源QUIC库也选择了BoringSSL，对于一些既有的，已经基于OpenSSL实现的产品，想要切换到BoringSSL去集成这些QUIC库绝不是一件容易的事。不过好就好在，有问题总有解法，我们在我们开源的[BabaSSL库](https://github.com/BabaSSL/BabaSSL)中对QUIC-TLS做了全量实现，并且也兼容了部分BoringSSL的Api使用，这部分也经过了生产考验，欢迎各位读者来体验一下，当然不仅如此，对于前文QUIC-TLS展望中提到的技术，我们也正在或者已经完成了实现，欢迎各位读者前来尝鲜。