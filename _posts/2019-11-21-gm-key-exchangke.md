---
layout: post
title: 深入理解国密算法---国密密钥交换算法详解
categories: Network
keywords: TLS, GM, Network
---

## 背景       
对于做密码安全相关的同学，国密算法应该不是一个陌生的词汇了，随着国家对于密码安全的重视，在2011-2014年出台了一系列国密算法的标准，并要求相关金融机构在2022年必须全面支持国密算法。然而国密算法最初设计的目的，并非是针对互联网的大规模https场景的，即使国密的标准文档，对于密钥交换流程的描述也是相对杂乱的，在对比文档和一些标准实现时，很容易使人产生疑惑，因此才有了本文。

当然，本文核心目的不是在于梳理文档，而是希望能通过这一篇文章节省大家查阅文档浪费的时间，减轻大家理解算法的痛苦。本文将会对于国密依赖的双证书体系做简要说明，并详细阐述并分析密钥交换的流程及其对应的算法，虽然国密算法在很多方面令人诟病，但其本身的设计还是挺有意思的，对于椭圆曲线理论感兴趣的同学可以看一看，可以加深对算法的认识，也可以更深入的了解下https中是如何进行密钥交换的。

本文依赖的一些基本知识：PKI公钥体系的基本流程，了解基本的密钥交换算法RSA,ECDHE的概念(如果不清楚也没关系，本文将会简明的阐述这些基本的概念，并附带一些讲解细节的链接），OK，下面开始我们的正文


## 国密文档概览
先让大家对于国密文档的有一个感受，要了解国密的密钥交换流程，首先要对国密的双证书体系有一个了解，[双证书体系的相关介绍可以看这里](https://max.book118.com/html/2017/0122/86057592.shtm?spm=ata.21736010.0.0.555937b2eB059u&file=86057592.shtm)，我这里可以大致解读一下，所谓的双证书体系，则是在原来用于身份认证的签名证书的基础上，新增了一个加密证书。双证书体系的目的在于国家需要对特定机构进行强监管，即具备随时获取被监管机构的明文消息的能力。熟悉PKI公钥体系的同学知道，对于密钥交换流程来说，依赖的是一个公私钥对，如果私钥泄露，则意味着与该私钥相关的会话信息都可以被破译，双证书体系则是会话过程的私钥依赖双证书中的加密证书导出，加密证书则是由国家机构颁发，通过这种方式，实现了国家对于特定机构的监管。而签名证书则可以由任意权威机构颁发即可。

除了双证书，国密基于tls1.1的密钥交换流程和椭圆曲线算法定义了新的国密密钥交换算法，统称SM2密钥交换算法，实际上有两个密钥交换算法，本文称作ECC-SM2和ECDHE-SM2，对于国密的密钥交换标准流程定义在[GMT-0024-2014 SSL-VPN技术规范](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200024-2014%20SSL%20VPN%20%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83.PDF?spm=ata.21736010.0.0.555937b2eB059u&file=GMT%200024-2014%20SSL%20VPN%20%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83.PDF)中，然而该文档对于密钥交换流程的描述实质上几乎只是对TLS1.1的RFC的翻译，对于具体的套件和国密密钥交换流程中独有部分的描述相当之少，只在一些关键的地方提出了一些标准的定义以及描述，而具体的套件流程又定义在以下两个文档中：

- [GMT 0003.3-2012 SM2椭圆曲线公钥密码算法第3部分：密钥交换协议](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200003.3-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC3%E9%83%A8%E5%88%86%EF%BC%9A%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE.pdf?spm=ata.21736010.0.0.555937b2eB059u&file=GMT%200003.3-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC3%E9%83%A8%E5%88%86%EF%BC%9A%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE.pdf)
- [GMT 0003.4-2012 SM2椭圆曲线公钥密码算法第4部分：公钥加密算法](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200003.4-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.pdf?spm=ata.21736010.0.0.555937b2eB059u&file=GMT%200003.4-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.pdf)

标准文档读起来还是挺晦涩的，如果大家不敢兴趣可以完全不用看，直接看我下面对国密的密钥交换流程及算法的分析。

### 国密密钥交换流程及算法
对于PKI公钥体系来说，密钥交换算法是基石，何为密钥交换算法，即client与server可以在交换有限的信息下得出相同的数据来。目前典型密钥交换算法rsa，ecdhe，下面我们将以与这些经典密钥交换算法对比的方式讲解国密密钥交换算法，为了后面描述方便，密钥交换的算法及其相应的流程我们就以"cipher"来代替，即“ECC-SM2这个cipher”表示“ECC-SM2密钥交换算法及其相应的流程”。

### ECC-SM2
ECC-SM2在流程上几乎等同于RSA的密钥交换流程，更准确的说法是基于椭圆曲线的原理实现了一种可以用公钥加密，私钥解密的算法，这种密钥交换算法由于不需要client持有证书，相对另一种国密算法ECDHE-SM2来说普适性更强，也是目前360国密浏览器唯一支持的国密算法。下面我们来详细看下这个算法的流程，如果你对算法本身不感兴趣，可以直接跳过。

了解算法流程之前，我们可以先简单回顾下RSA的密钥交换流程，简单来说，RSA算法的性质为公钥加密的数据只能私钥解密，私钥加密的数据只能公钥解密(具体原理可以看这里：RSA的数学背景知识，RSA的原理)。RSA的密钥交换流程如下图：

![](/images/self-drawn/gm-key-exchange/rsa.png)

我们这里再稍微提一下ECC曲线的基本知识，[想详细了解ECC算法原理的同学可以看这里](https://blog.csdn.net/qmickecs/article/details/76585303?spm=ata.21736010.0.0.555937b2eB059u)，这里也只给一个简要说明，ECC算法会定义一个椭圆曲线基点G，并且定义椭圆曲线域上的加法和乘法运算，其安全性在于计算：k(任意正整数) * G(椭圆基点) = A(椭圆曲线上的一个点)很容易，但知道G和A，算k却很难。有了这部分基础知识，我们来看ECC-SM2算法的原理，先来看ECC-SM2的加密流程，加密流程主要发生在client端，client拿到加密证书后对密钥材料用公钥加密发送，这里盗一张官方文档图，然后我们对其进行详细讲解:

![](/images/self-drawn/gm-key-exchange/ecc-sm2-enc.png)

首先注意不要把长度klen和随机数k混淆了，他们没有任何关系，椭圆曲线的基点G就不用再说了，流程中的'[k]G'符号表示椭圆曲线里的k*G，单纯理解成乘法就行。公钥P<sub>B</sub>对应着私钥d<sub>B</sub>，实质上他们的对应关系为P<sub>B</sub> =d<sub>B</sub> * G，也就是说从数学上来看私钥d<sub>B</sub>实际上是一个大数，而公钥P<sub>B</sub> 是一个椭圆曲线点。h为余因子，也叫辅助因子，作用在于验证当前曲线点是否有效。KDF是密钥派生函数，其作用是利用指定的hash函数将数据扩展到指定长度，国密中的hash函数确定为SM3。我们加密流程的输出实质上有三段数据:
- C<sub>1</sub>：用于导出加密材料的数据。
- C<sub>2</sub>:加密后的密文。
- C<sub>3</sub>：用于验证的数据。

我们再来看ECC-SM2的解密过程:

![](/images/self-drawn/gm-key-exchange/ecc-sm2-dec.png)

解密过程实际就是从C2中还原消息M的过程，从解密的流程可以看出，实际上我们只需要保证k * P<sub>B</sub> =d<sub>B</sub> * C1 ，server就可以拿到和client相同的t，从而完成私钥解密的过程。我们来证明一下这个流程，从前面我们得知P<sub>B</sub> =d<sub>B</sub> * G，C1 = k * G。实际上我们只需证明，k * d<sub>B</sub> * G =d<sub>B</sub> * k * G ，等式的成立是显而易见的。而后的C3主要是为了验证消息的正确性。

### ECDHE-SM2
从ECDHE-SM2这个cipher所在文档的名称就能看出来，它是官方想要主力推荐的cipher，相对与ECC-SM2以及标准ECDSA和RSA相关cipher来说，该cipher会更加的安全，然而从来没有真正的银弹，安全的代价是繁琐的流程以及更多的计算开销，甚至还需要client也满足一定要求，因此，现有的互联网公司几乎都在尽力避开这个算法套件，360浏览器干脆直接不支持这个套件了。在了解这个cipher的流程前，我们还是照例回顾下标准的ECDHE算法握手流程：

![](/images/self-drawn/gm-key-exchange/ecdhe.png)

而对于ECDHE-SM2这个cipher来说，虽然流程看起来繁琐了很多，但某些本质还是换汤不换药的，我们来看下这个cipher的流程，从流程图就能感受到它的繁琐：

![](/images/self-drawn/gm-key-exchange/ecdhe-sm2.png)

标准文档的流程图中并没有对于关键的密钥导出步骤进行说明，这里补充一下，大家关注下用户A的第七步和用户B的第六步，实际的计算流程如下(由于文档的限制，带有上标'-'的x1和x2就以x1和x2替代了，这个替换不会影响理解):

- 用户A：计算U = [h * t<sub>A</sub>](P<sub>B</sub> + x<sub>2</sub> * R<sub>B</sub>) = (x<sub>U</sub>,y<sub>U</sub>)，其中t<sub>A</sub> = (d<sub>A</sub> + x<sub>1</sub> * r<sub>A</sub>)，d<sub>A</sub>为A的私钥，P<sub>B</sub>为B的公钥
- 用户B：计算V = [h * t<sub>B</sub>](P<sub>A</sub> + x<sub>1</sub> * R<sub>A</sub>) = (x<sub>V</sub>,y<sub>V</sub>)，其中t<sub>B</sub> = (d<sub>B</sub> + x<sub>2</sub> * r<sub>B</sub>)，d<sub>B</sub>为B的私钥，P<sub>A</sub>为A的公钥

这里的"[]"还是表示椭圆曲线乘法，而x1和x2都是带有上标'-'的。

从流程图我们可以看到，用户A和用户B若要保证导出的密钥KA与KB一致，只需要保证U，V相等就行了，我们来证明一下U和V为什么相等，这里会多一点数学式子，但都是很简单的：

![](/images/self-drawn/gm-key-exchange/ecdhe-formular.png)

对于红框内的式子，这是一个看似显然，但实际很不显然的式子，我们很轻易就能够验证：(7 % 3) * 5 和(5 % 3) * 7是截然不同的结果，那么为什么U=V这个式子还能成立呢？这里需要对这个mod n进行说明，n表示椭圆曲线的阶，阶的定义为：在椭圆曲线域中，对于确定的基点G，当满足[K] * G = 0这个式子时，K的最小值称作椭圆的阶n。简单来说[n]*G=0，而由于椭圆曲线群满足分配率(即[a+b]G = [a]G + [b]G)，我们可以得到，对于任意数N有：[N] * G = [N mod n] * G (证明:N = k*n + (N mod n)) ，于是，上面的式子变为：

![](/images/self-drawn/gm-key-exchange/echde-prove.png)

这里的阐述相对啰嗦了一些，主要是希望没有接触过椭圆曲线理论的同学也能看的没有任何心智负担，流程图中后续的步骤10都是对于消息正确的验证，也就是做了一个hash然后对比结果，这里就不赘述了。

## 从算法流程看国密的问题
单从cipher的层面，我们也能看出不少国密的问题来，首先是ECC-SM2这个cipher，我们前面提到了，ECC-SM2这个cipher的握手流程和RSA的握手流程是一样的，回顾一下前面的流程图我们可以发现，client依赖server的证书才能够进行公钥加密，这意味着至少要2个RTT才能够完成握手，而也就是为什么现有的TLS1.3协议标准中废除了RSA的握手过程的原因，当然，聪明的你也肯定能从标准ECDHE密钥交换流程中看懂为什么TLS1.3能够实现1RTT会话建连。

看起来ECC-SM2这个cipher和时代已经有一些脱节，不过值得庆幸的是，从ECDHE-SM2这个cipher的流程图我们可以发现，虽然步骤繁琐，但取消掉步骤10这个可选项，我们也是可以实现1RTT握手的。然而ECDHE-SM2这个cipher本身的问题比ECC-SM2还要严重，严重到甚至完全不可接受的地步。首先就是相对于标准ECDHE算法来说超高的计算开销，从流程图我们可以发现，这个开销不光是加在server端，client端也难以逃避，而对于移动终端来说，如此高额的计算开销带来的功耗，时延，发热，卡顿等问题，都十分令人头疼。而更加严重的是，算法要求client必须持有证书，从算法层面我们来看，几个公式的变换依赖的是双方使用相同的椭圆曲线的基点G，这也就意味着，client的证书必须是和server一样的证书，而且必须是国密证书，同时也必须是同一条曲线同一个基点，其扩展性令人担忧。从应用层面来看，在client预埋证书带来的存储开销，以及通信过程传输证书带来的额外开销就已经不太能令人接受了，又何况本身推进所有client持有证书也是一个难题，各种浏览器，特别是Firefox，chrome之类，他们很大概率不会接受持有证书的方案，这也就是为什么这个cipher在互联网公司中几乎没有任何应用场景的原因。