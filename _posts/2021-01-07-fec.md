---
layout: post
title: FEC随想---在传输协议中的应用
categories: Network
keywords: fec
---

## 背景       
先说下为什么要写本文，FEC(Forward error correction，前向纠错[码])本身，绝对不算一个新概念，即使是FEC在传输层的应用，也算不得什么新东西，比如webrtc中就应用了FEC，还有相关的标准。但是如果你想深入了解FEC的话，你一搜相关概念，多半都是一大堆通信术语，对非通信专业的同学很不友好。所以，我想通过这篇文章，帮助大家弄清楚：

1. FEC究竟是什么东西？
2. 既然FEC是一门底层通信的技术，又是怎么应用到上层的？
3. 还有，目前的相关应用有哪些
4. 还有可以挖掘的空间吗？

本文开始前，先定义清楚题目中的两个名词：

- FEC：Forward error correction，前向纠错编码，是纠错编码的子集，随着技术的发展，现在两者基本可以划等号了，在传输层中又有人称FEC为Forward erasure correction，两者只是为了区分当以bit或数据包作为单位时发生错误的相应行为，没有本质区别区别，所以为了称呼简洁，本文中FEC=Forward error correction=前向纠错编码=纠错编码。
- 传输协议：本文中的传输协议主要指传输层协议，包括各种能提供数据包可靠交付能力的协议。

这篇文章的题目起的有点大，无论是纠错编码还是传输协议，单独都可以拿出来成一门独立的学科，其中每个典型的技术，都可以拿来写好几篇文章。所以我放弃尝试拿其中某个具体的技术点来精讲，而是通过一个简单的FEC设计示例，帮助大家理解FEC到底在解决什么问题，以及它使用于什么场景，并在此基础上分析下好的FEC应该是什么样的，OK，下面开始我们的正文。

## 何为FEC
FEC，或者说纠错编码，这是一门诞生在数据链路层的核心技术，可以说没有这门技术，就没有我们现在如此方便的通信体系，要了解何为纠错编码，首先我们要知道链路层的数据传输存在什么样的问题。我们尝试用一个最简单的例子来让大家对纠错编码有一个体感。

在链路层的通信中，抛去繁杂的理论，从逻辑上而言，就是简单的点对点通信，通信的发端发送的是一串连续的0/1bit流，只是信息的载体不一样，比如无线通信载体为电磁波，固网用光纤等。假设发送端准备发送三个bit，记作：

```
{b1, b2, b3}
```

这一串0/1bit流在传输过程中，难免会受到各种层面的干扰，比如建筑遮挡，各种其他信号的影响等，作为通信的收端，我们首先面临了这个问题：1. 我怎么知道我收到的bit流是正确的呢？当然，我们最直接的反应是加一些冗余的校验信息，比如，最简单的[奇偶校验](https://zh.wikipedia.org/wiki/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D)，现在，我们多了一个校验bit，记作：

```
b4 = b1 ^ b2 ^ b3
```

我们将其一并发送。假设在发送过程中，{b1, b2, b3}之间的一个bit出现了误码，接收端通过检验式b1 ^ b2 ^ b3 ^ b4 != 0就可以判断出来误码的发生，但是，我们此时并不知道究竟哪个bit发生了误码，我们只能通过通知发端，发送过程有误码，请重发数据，即ARQ机制。而我们知道，链路中的一个来回所带来的开销，通常比数值计算大多了。所以，此时我们又面临了新的问题：2.我收到的数据出了错误，我有没有什么手段，不通过ARQ，直接恢复出数据？

我们来尝试把在冗余的数据里多加一些东西，使其既可以完成数据校验，同时又可以恢复数据，假设我们通过某些的手段，知道了信道中最多发生1bit误码，我们开始设计如下几个冗余bit，使其既带有校验信息，同时又保留原始数据信息，我们记

```
b4 = b1 ^ b2
b5 = b1 ^ b3
b6 = b2 ^ b3
```

对于收端，我们可以通过以下式子来验证传输过程没有问题

```
(1) b4 ^ b1 ^ b2 = 0
(2) b5 ^ b1 ^ b3 = 0
(3) b6 ^ b2 ^ b3 = 0
```

通过这几个校验式，传输过程任何一个bit发生了误码，我们都可以识别出来，比如b2发生了误码，则校验式(1),(3)无法通过，1,3的共有元素只有b2，则我们知道b2发生了误码，相应如果校验bit发生比如b4误码，仅会有校验式(1)无法通过，我们就会知道b4发生了误码，误码的处理也很简单，bit只有0/1两种状态，直接翻转即可。

至此，我们完成了最简单的纠错编码设计，这种码字叫做Hanmming码，也是最早出现的纠错编码码字。我们把整个流程换成高大上的通信术语和数学式子再讲一遍：

- 首先，我们进行了信道估计(知道信道只会出现1bit误码)
- 然后，我们设计了一个生成矩阵G，我们记编码符号为S，则整个编码过程可以用如下式子表示

![](/images/self-drawn/fec/f1.png)

其中

![](/images/self-drawn/fec/f2.png)

而校验过程我们可以抽象成一个数学表达式，我们记校验矩阵为H，我们可以得到

![](/images/self-drawn/fec/f3.png)

根据左单位阵的特性，我们可以得到

![](/images/self-drawn/fec/f4.png)

我们可以看到其实H和G基本是互相等价的两个矩阵，确定了其中一个，另一个也就确定了。至此，通过数学语言，我们也基本描述了纠错编码中的分组码这部分每一个单一数据块的编解码过程，这里我们提出了分组码的概念，分组码的定义为：将信源的信息序列分成独立的块进行处理和编码。纠错编码中的分组码这部分技术设计流程就是在不断的折腾这个H，以解决我们在链路层传输的问题。至此，我们可以做一个小结，FEC需要完成两个最基本的功能：

1. 校验传输过程数据是否有差错。
2. 数据有差错可以尽可能识别出来并恢复它。

再回到我们的例子中来，可以发现，虽然我们通过信道估计确认了只会有1bit误码，但信道估计肯定不可能百分百正确，当出现2bit误码时，我们的校验就会失败，同时也没办法进行数据恢复。这时，我们还是只有依赖ARQ机制来进行重传，此时，我们面临着第三个问题：3.当信道估计不准确时，怎样设计FEC才能尽量减少ARQ的损耗？相应的技术就是喷泉码了，典型的喷泉码如[LT码](https://www.semanticscholar.org/topic/Luby-transform-code/103092)，[raptor码](https://datatracker.ietf.org/doc/html/rfc5053)，也可以归类到分组码这个范围中，至于其相关技术的细节，后文会提到。

在上面例子中，{b4, b5, b6}都是冗余的信息，如果在传输过程中冗余信息过多，肯定是会影响传输效率的，这里先普及一个码率的概念，码率反应的是信息的冗余度：

```
码率 = 源信息数量 / 编码后信息数量
```

比如在我们的示例Hamming码中，码率就为1/2。同时，这里也就引出了我们的第4个问题：4.如何让编码的冗余度尽可能少(即码率尽可能高)？过高的冗余度是对信道资源的浪费，好的码字的设计应该是在保证解决前三个问题的情况下，尽可能的低冗余度的，香农第二定理给出了编码效率的理论上限。码字的设计应当尽可能的逼近香农限。

至此，我们又可以做一个小结，FEC需要解决两个问题：1. 差错校验 2. 数据恢复。同时，FEC还需要兼顾两个问题：1. 在不确定的传输环境下，尽量不发生ARQ错误重传。2. 编码冗余度尽可能的低。

分组码通过不断折腾生成矩阵/校验矩阵，以最小的冗余度来保证每一次传输都可以不存在误码。这部分的技术除了文中用来做介绍的Hamming码之外有很多，最典型的就是[LDPC编码](https://web.stanford.edu/class/ee388/papers/ldpc.pdf)了，目前LDPC已经成为了5G长码的标准。

当然纠错编码技术除了分组码之外还有很多技术。但应用到传输层的主要就是分组码这部分了，这里就只把其他相关技术做个简单介绍吧：

1. 卷积码，典型如[Turbo码](https://ieeexplore.ieee.org/abstract/document/539767)，引领了3G时代，是LTE中编码技术的代表，卷积码的编码系统是一个状态反馈系统，即当前时刻的编码依赖上一次编码的输出，而译码过程则是通过最大概率状态转移路径进行。这部分没有办法写成类似分组码的编码过程，也就无法应用到传输层中，至于为什么无法应用，后文会提到。
2. 极化码，基本就是指[Polar码](https://ieeexplore.ieee.org/abstract/document/6557004)，目前已经成为5G的短码标准，也是华为主推的标准，极化码的思想在于无线信道的极化特点：随着各个子信道的不断分裂和联合，各子信道会出现好的特别好，差的特别差的现象。可惜传输层似乎不拥有这种特性，否则基于Polar码设计传输层的FEC也会是一个不错的选择。

本章最后再补点题外话，有的同学就要问了，上述编码设计只有在1bit误码的时候才可以用，其他时候不就发生误判了吗？比如2bit误码，一是可能检测不出来发生了错误，二是有可能发生错误的判定。

这是个好问题，问题的答案在于：在实际应用中，纠错编码的设计是离不开信道估计的。这句话有点抽象，举个例子，在实际应用中，我们所有通信过程的实现，对信道误码率(误bit率)是有诉求的，比如最简单的打电话操作，要求误码率在10e-4以下，高于这个误码率，你听到的话音就是杂音了，而实质上由于通信技术本身的发展，在我们的实际生活应用中(比如手机通话，无线上网)，误码率基本都在10e-6或10e-7之下，所以其实一个分组只有一个bit误码是很正常的。当然，本文只是一个简单的示例，通用的纠错编码码字基本没有这种1bit误码的要求，但是相应技术也不能百分之百保证不发生误判，所以，这也是IP层为什么要做checksum的原因之一。

## 传输层为什么可以用FEC
回顾上一章的链路层面临的四个问题：

1. 我怎么知道我收到的数据是正确的呢？
2. 如果我收到的数据出了错误，我要怎么恢复出正确的数据
3. 如何减少ARQ的过程
4. 如何让信息冗余度尽可能低

我们再来看看典型的传输层协议期望解决的问题

1. 如何保证发送端所有的数据包的可靠传输
2. 如何让整个过程变得高效(减少RT，也可以说就是在减少ARQ过程)
3. 如果我采用某种技术解决2的问题，那么这种技术的开销能不能尽可能的小

从目标上来说，两者在减少ARQ过程，减少信息冗余度的诉求上，是完全一致的，看起来有足够的共性，但两者又有一些本质上的不同点：

1. 数据的基本单位不同，链路层面临的单位是bit，而传输层面临的单位是数据包。
2. 传输层的数据包只存在两种情况，收到/没收到，即要么收到就都是正确的，要么就全错，即没收到。同时也就意味者传输层的数据包不需要进行校验操作。
3. 错误处理方式不同，对于链路层，我只需要知道哪个bit发生了错误，翻转即可，而对于传输层，我们往往知道哪个数据包发生了丢包，但要恢复只能靠重传或者其他有关联信息的数据包。

从这些条件看来，在某种程度上，传输层问题反倒是链路层问题的简化版(不需要做校验)，但纠错层面的诉求带来的分歧似乎是不可调和的，别急，回顾一下第二章中的纠错表达式，以(1)为例，得益于二元域的性质。假设我们知道b1发生了问题，我们不仅可以用bit翻转的形式得到正确的b1，我们也可以用b1 = b4 ^ b2来求得正确的b1。

有了这一层抽象，传输层和链路层这部分的共性就找到了，我们还是以第二章中的Hamming码作为例子，仍旧是发送{b1, b2, b3}，但{b1, b2, b3}表示的是三个数据包，我们还是可以沿用上面的生成矩阵G来进行编码，得到{b1, b2, b3, b4, b5, b6}，同样，其中任何一个包丢包，我们都可以通过纠错表达式进行恢复。不仅如此，由于我们不需要校验哪个数据包发生了问题，那么即使丢大于1个的包，我们也可以进行恢复，我们尝试用数学语言来更直观的表达这个过程：

其中编码过程和上文是一致的：

![](/images/self-drawn/fec/f5.png)

由于我们并不需要进行校验，则译码过程可以直接写作：

![](/images/self-drawn/fec/f6.png)

其中G^g为矩阵G的广义逆矩阵，拥有广义逆矩阵的条件是矩阵G的秩为3(即{b1, b2, b3}中元素的个数)。任意的丢包反应在接收到的矩阵中，则为编码包对应生成矩阵G的当前列丢失。数学语言有点抽象，用一个示例来描述，比如我们编码包b4，实质上是通过{b1, b2, b3}乘矩阵G的第4列得到的，如果b4丢包，从发端来看，就是b4对应生成矩阵该列没了

![](/images/self-drawn/fec/f7.png)

而如果我们想恢复包，实际就是一个通过S和G去求解方程组，得到{b1, b2, b3}的过程，而这个过程有解的充分必要条件，就是矩阵秩为3(三个方程组，三个未知数)，也就是说，只要我们接收的数据包在矩阵G中对应的列向量组合起来，能保证秩为3，就一定能成功译码。

![](/images/self-drawn/fec/f8.png)

通过这个示例，我们可以有清晰的体感：链路层分组码基本可以直接应用在传输层，并且由于传输层某些特性(能明确知道数据包是否正确接收)，分组码在传输层上表现的性能会更好(相同冗余度，可以恢复更多的数据)。有了这个结论，我们就可以尽可能的把链路层的分组码的优秀特性应用到传输层，以解决传输层面临的问题，比如：

### ARQ过程的优化
还是上述示例，我们只需要保证接收方把接收到的包对应的列向量重组起来，保证秩为3就行，那么我们就可以沿用分组码中依赖信道估计设计码字的思想，以{b1, b2, b3}为例，比如我们能估计出来丢包率25%，那么我们可以设计b4 = b1 ^ b2 ^ b3，那么任意丢弃一个包，都可以通过其他包进行恢复。如图：

![](/images/self-drawn/fec/f9.png)

当然，信道估计一定是不准确的，我们又设计了一种手段，让发送端不断的生成编码包，直到接收方可以成功恢复数据后，再回复确认消息即可，还是以{b1, b2, b3}为例，这部分的流程可以用这个式子来描述

![](/images/self-drawn/fec/f10.png)

而这就是喷泉码的思想，可以看到，在这种情况下，我们的码率是不固定的，所以，喷泉码也叫无速率码。通过喷泉码的方式，我们可以最大程度的减少ARQ中错误重传的次数。这也就是为什么在丢包较高/RT较长的场景下，我们通常会采用喷泉码来解决问题的原因。这里再补一个题外话，IP组播场景下由于各条子链路丢包情况是不同的，所以利用喷泉码这种任意包丢失都可以进行数据恢复的性质，会达到很好的效果。

### 减少编码冗余
在使用喷泉码解决ARQ过程中，我们是通过随机生成列向量的方式来进行编码的，这不可避免的会造成大量重复的数据，浪费信道资源，而我们需要某些设计来减少冗余度。而这部分的技术比如：

1. LT码-通过鲁棒孤波分布的设计来最小化冗余度
2. raptor码-在LT码基础上引入预编码，通过LDPC编码和Half编码，将每个编码包携带原始信息的数量做平均，更大程度的减少冗余

到这里，我们基本知道了为什么分组码可以用到传输层上，同时也就基本知道了其他类型的传输层FEC无法使用的原因，以卷积码为例，在传输层以包为单位，由于其编译码过程依赖状态的连续性，无法写成这种矩阵相乘的形式，也就无法进行这种简易的编解码过程。

至此，我们对于FEC的流程也有了一定的了解，我们可以对FEC在传输层协议的应用，做一个总结。首先编解码一定意味着算法的开销。所以，在：

1. 链路RT的开销大于计算开销时
2. 链路存在某些特殊行，比如多播场景每个信道的情况不一样这种

这些情况情况下，基于FEC去设计传输协议，往往能得到非常大的收益。

## 我眼中的FEC在传输层的最佳实践
前几章探讨了一下纠错编码中一些特定的码字，以及其解决的问题，然而要将FEC良好的应用到传输协议中去却并非十分简单，正如某些纠错编码的参数设计，依赖于信道估计一样。在传输层想良好的运用FEC，也离不开对传输链路的估计。有了对链路的估计，我们可以对码字做自适应调整，而这调整应该是两个方面的：

1. 传输层对到底使用什么码字做自适应调整，编解码本身是一个trade off，简单的编码虽然在提升ARQ层面上可能较弱，但其计算复杂度会很低，所以根据网络情况挑选适应的码字会带来更好的性能。
2. 码字本身针对链路做码率调整，如链路层FEC一样，链路情况好，就提高码率，链路情况差，则降低码率，提高冗余度

所以，基于上述的思考，我眼中FEC在传输层中的最佳应用应当是这样：

### FEC和传输层的拥塞控制做结合
首先这里提的是结合而不是耦合，正如上文所说，既然FEC需要依赖到信道估计，而在传输层而言，直接得到信道情况反应的部分就是拥塞控制模块了，所以FEC应当是和拥塞模块紧密结合的。但是相应的FEC是否要作用到拥塞控制上来，我觉得倒不一定，因为不管怎么说，即使数据进行了编码，仍旧是在拥塞控制层面之上的数据，沿用现有的拥塞控制也未尝不可。但如果某些场景下，编码的反馈也许能作用到拥塞控制上，比如告诉拥塞我这里的数据都不关键，都可以丢弃，那么拥塞部分采用更激进的方式去传输数据也是可以的。这部分目前还没有相关的研究，感兴趣的同学可以下来一起探讨一下。

### 传输层提供FEC的协商框架，而不是限定于某种FEC
正如前文所说，编码的算法应该也是自适应的，复杂的算法未必就能在实际应用中带来更好的表现，所以传输层应该提供某种协议供通信双方做FEC的协商，这部分QUIC已经走在了前面，目前quic针对FEC设计了一种框架，并提交了相关[draft](https://datatracker.ietf.org/doc/html/draft-swett-nwcrg-coding-for-quic-04)，感兴趣的同学可以自行了解。

### 选择的FEC应当是系统码,并且具备自适应的特征
这里提到了系统码的概念，所谓的系统码，就是在编码后生成的数据里，仍然带有未加工的原始数据，这样的好处是，如果信道状况极佳，那么我不用做任何运算，就能拿到原始数据，举例来说，本文设计的Hanmming码就是系统码，最原始的喷泉码设计就是非系统码。可以说，系统码本身就带有一定的自适应能力，码字本身应当也设计一些自适应的流程，比如本文设计的Hamming码，最优解应当是在丢包率不同的情况下生成不同数量的编码包，同时编码包的列向量设计也应当有一定变化。

### FEC的编解码过程使用硬件加速
从前面编解码的流程可以看到，编解码的过程实质上是简单的矩阵计算，而由于传输层协议往往使用cpu进行相关处理，难以达到最佳性能，这部分使用一些SIMD技术，或者直接利用GPU，FPGA进行加速，能达到更好的处理效果。

## Beyond FEC
整个FEC的视角都是围绕着点对点通信在进行，当我们把视角拉大一点，如何提升整个网络的吞吐量呢？这里需要提一个技术，网络编码，以网络编码经典入门示例蝶形图来说明，首先我们先给出一个网络整体吞吐量的衡量公式：

```
网络吞吐量 = 有效传输的数据 / 数据传输消耗的时间
```

我们来看这样一个网络拓扑

![](/images/self-drawn/fec/f11.png)

在这样一个网络中，A期望给B/C广播消息{a, b}，如果所有中间节点只能做转发流程的话，无论你的传输路径如何设计，总有一条链路一定需要经过两次传输过程，才能成功将数据交付到B/C。而如果中继节点M2可以对数据进行一次异或操作的话，那么所有链路只需要走一次，就可以完成数据的投递，对应到公式中，数据传输的消耗时间减少了，网络的吞吐量也就增加了。

为什么会提到这样一个技术，我们以比较数学的方式来描述M1->M2这条链路：其发送的数据实质上为:

![](/images/self-drawn/fec/f12.png)

同样，M2->M3的链路，可以抽象为：

![](/images/self-drawn/fec/f13.png)

式子是不是很眼熟，对，和前面FEC的生成基本是一样的，每个中继节点M的传输过程实质上也可以抽象成一个原始数据*生成矩阵的这样一个流程，我们再把FEC加进来，还是以{b1, b2, b3}为例，对于FEC在网络编码中每个节点的传输过程，我们实际上可以写成：

![](/images/self-drawn/fec/f14.png)

之前，我们在说，FEC就是在不断折腾生成矩阵G，那么现在我们把网络编码提升全局容量的条件考虑进来，我们实质上就是折腾这个G_global了，从理论上来说，G_global合理的设计既能带给我们传输层面的提升，又能提升全局的网络容量，但是，这的确不是一个容易的事情，目前有一个相关的研究，BATS码，在这条路上走出了第一步，然而也仅仅是设计了简单网络拓扑下的相关传输流程，因为当网络拓扑复杂的时候，相关计算的复杂度不仅仅是几何倍数的增长。

## 结语
传输层FEC应用可以说是一个上下限很高的一个领域，很多时候，某些问题用简单的FEC就可以得到缓解，但想要做到极致，对于数学，网络，编码相关知识的要求都非常非常高，本文对于一些典型的技术，基本只是提了一下其应用场景和特点，对细节感兴趣的同学可以下来一起探讨一下。当然，本文某些方向的看法和观点也不一定很深入，如果读者有不同的想法或者发现文章有什么纰漏之处，欢迎直接联系我讨论，感谢。