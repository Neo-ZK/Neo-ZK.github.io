---
layout: post
title: 深入理解国密算法---国密密钥交换算法详解
categories: Network
keywords: TLS, GM, Network
---

## 背景       
传统的基于边界的网络安全架构通过防火墙、WAF、IPS等边界安全产品/方案对企业网络边界进行重重防护，然而随着近些年云技术的不断发展，各个企业也在不断拥抱公有云，专有云以及混合云的架构模式，网络安全的边界也在不断模糊。在云模式下，即使进入逻辑上的企业内网环境，也很难保证网络的安全，由此，John Kindervag在2010年提出的零信任网络模型逐渐走入大家的视野，零信任网络模型的目标是基于身份和访问控制从0构建企业新的逻辑边界，在零信任网络的范式下，在现有的体系上如何对每台设备进行安全的身份认证是一个不小的挑战。今天要分享的Delegated Credentials技术属于身份认证技术的一种，由FaceBook和CloudFlare在17年提出，其目的在于给出一种新的身份认证方式，并基于此提升私钥管理的安全性。本文将对这项技术的细节以及优劣进行分析，阅读本文大概需要20分钟。章节安排如下：

- 第二章将简单描述PKI体系下身份认证的流程，以及其在云环境下面对的挑战。
- 第三章将简单阐述Delegated Credentials解决问题的思路和其对应的一些技术的分析。
- 第四章对Delegated Credentials这项技术的细节做一些说明。
- 第五章对Delegated Credentials技术的优劣进行了一些总结和评价。


## PKI下的身份认证流程及其面对的挑战
整个PKI身份认证体系的核心是数字证书及其对应的私钥，目前的数字证书均按照x509结构，我们以普通的web浏览器访问网站的流程为例，稍微详细的说明下一个x509证书的结构及其对应的身份认证流程，本文默认的标准是x509 V3(这也是当前默认的证书标准)。当我们在验证证书是否有效时，我们实质验证的是一个证书链，整个证书链的结构如下：

![](/images/self-drawn/intro-of-delegated-credential/cert.png)

完整的身份流程如下：

- 在client发起会话请求前，会在浏览器中导入信任的CA证书(即图中根证书)，这个CA证书一般由权威机构发放。
- client与server成功的建立起会话后，会收到server的证书链(对应图中的网站证书及一级证书)，以及server对本次会话的关键信息的签名，然后开始验证流程。
- client首先使用网站证书的公钥来验证server提供的本次会话的关键信息的签名(具体验签流程可以参看ECDSA和RSA签名及验签算法)，验证成功则说明client当前会话的对端是网站证书所有方(即没有中间人篡改信息)，但网站证书并不受信任，下面开始向上验证证书链。
- client通过server提供的证书链，拿到网站证书的上级证书(即图中的一级证书)，并通过一级证书中的公钥字段及网站证书的签名字段进行验证，验证成功则说明网站证书是由一级证书颁发且没有被篡改，但此时的一级证书仍不受信任，因此继续递归向上，通过一级证书的颁发机构字段向上搜寻证书。
- 重复上述步骤，验证一级证书是由其上级证书颁发且没被篡改，而此时我们能在浏览器中发现我们信任了根证书，则这条证书链是被信任的，则整个会话是被信任的。

实际应用中，证书链可能比较长，即不仅有一级证书，还可能有二级，三级..证书，但验证流程都是步骤4的递归重复。

PKI体系是目前身份认证方法中最安全的体系之一，但这套体系仍面临着不小的挑战：从流程我们可以看到，身份认证的安全性完全由公私钥对提供的算法来进行保证，而一旦一条证书链上某一个证书对应的私钥泄漏，那么该证书包括其以下的证书全都不再可以信任。私钥泄漏以后造成的影响是巨大的，首先，私钥泄漏意味着中间人可以随意冒充网站的身份与client进行通信，其次，从验证证书链的流程我们可以看到，验证流程只有递归向上的部分，这也就意味着我们除了在浏览器配置单独不信任某个证书以外，没有其他任何办法来处理某个私钥已经泄漏的证书。而client的行为是难以控制的，很难保证每个client都及时同步哪些证书已不再能被信任，相应的处理方法如典型的[Online Certificate Status Protocol (OCSP)](https://datatracker.ietf.org/doc/html/rfc6960)，以及chrome的[CRLsets](https://www.imperialviolet.org/2012/02/05/crlsets.html)，都没能很好的解决这个问题。


除了双证书，国密基于tls1.1的密钥交换流程和椭圆曲线算法定义了新的国密密钥交换算法，统称SM2密钥交换算法，实际上有两个密钥交换算法，本文称作ECC-SM2和ECDHE-SM2，对于国密的密钥交换标准流程定义在[GMT-0024-2014 SSL-VPN技术规范](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200024-2014%20SSL%20VPN%20%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83.PDF)中，然而该文档对于密钥交换流程的描述实质上几乎只是对TLS1.1的RFC的翻译，对于具体的套件和国密密钥交换流程中独有部分的描述相当之少，只在一些关键的地方提出了一些标准的定义以及描述，而具体的套件流程又定义在以下两个文档中：

- [GMT 0003.3-2012 SM2椭圆曲线公钥密码算法第3部分：密钥交换协议](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200003.3-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC3%E9%83%A8%E5%88%86%EF%BC%9A%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE.pdf)
- [GMT 0003.4-2012 SM2椭圆曲线公钥密码算法第4部分：公钥加密算法](https://github.com/guanzhi/GM-Standards/blob/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200003.4-2012%20SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.pdf)

标准文档读起来还是挺晦涩的，如果大家不敢兴趣可以完全不用看，直接看我下面对国密的密钥交换流程及算法的分析。

### 国密密钥交换流程及算法
对于PKI公钥体系来说，密钥交换算法是基石，何为密钥交换算法，即client与server可以在交换有限的信息下得出相同的数据来。目前典型密钥交换算法rsa，ecdhe，下面我们将以与这些经典密钥交换算法对比的方式讲解国密密钥交换算法，为了后面描述方便，密钥交换的算法及其相应的流程我们就以"cipher"来代替，即“ECC-SM2这个cipher”表示“ECC-SM2密钥交换算法及其相应的流程”。

### ECC-SM2
ECC-SM2在流程上几乎等同于RSA的密钥交换流程，更准确的说法是基于椭圆曲线的原理实现了一种可以用公钥加密，私钥解密的算法，这种密钥交换算法由于不需要client持有证书，相对另一种国密算法ECDHE-SM2来说普适性更强，也是目前360国密浏览器唯一支持的国密算法。下面我们来详细看下这个算法的流程，如果你对算法本身不感兴趣，可以直接跳过。

了解算法流程之前，我们可以先简单回顾下RSA的密钥交换流程，简单来说，RSA算法的性质为公钥加密的数据只能私钥解密，私钥加密的数据只能公钥解密(具体原理可以看这里：RSA的数学背景知识，RSA的原理)。RSA的密钥交换流程如下图：

![](/images/self-drawn/gm-key-exchange/rsa.png)

我们这里再稍微提一下ECC曲线的基本知识，[想详细了解ECC算法原理的同学可以看这里](https://blog.csdn.net/qmickecs/article/details/76585303)，这里也只给一个简要说明，ECC算法会定义一个椭圆曲线基点G，并且定义椭圆曲线域上的加法和乘法运算，其安全性在于计算：k(任意正整数) * G(椭圆基点) = A(椭圆曲线上的一个点)很容易，但知道G和A，算k却很难。有了这部分基础知识，我们来看ECC-SM2算法的原理，先来看ECC-SM2的加密流程，加密流程主要发生在client端，client拿到加密证书后对密钥材料用公钥加密发送，这里盗一张官方文档图，然后我们对其进行详细讲解:

![](/images/self-drawn/gm-key-exchange/ecc-sm2-enc.png)

首先注意不要把长度klen和随机数k混淆了，他们没有任何关系，椭圆曲线的基点G就不用再说了，流程中的'[k]G'符号表示椭圆曲线里的k*G，单纯理解成乘法就行。公钥P<sub>B</sub>对应着私钥d<sub>B</sub>，实质上他们的对应关系为P<sub>B</sub> =d<sub>B</sub> * G，也就是说从数学上来看私钥d<sub>B</sub>实际上是一个大数，而公钥P<sub>B</sub> 是一个椭圆曲线点。h为余因子，也叫辅助因子，作用在于验证当前曲线点是否有效。KDF是密钥派生函数，其作用是利用指定的hash函数将数据扩展到指定长度，国密中的hash函数确定为SM3。我们加密流程的输出实质上有三段数据:
- C<sub>1</sub>：用于导出加密材料的数据。
- C<sub>2</sub>：加密后的密文。
- C<sub>3</sub>：用于验证的数据。

我们再来看ECC-SM2的解密过程:

![](/images/self-drawn/gm-key-exchange/ecc-sm2-dec.png)

解密过程实际就是从C2中还原消息M的过程，从解密的流程可以看出，实际上我们只需要保证k * P<sub>B</sub> =d<sub>B</sub> * C1 ，server就可以拿到和client相同的t，从而完成私钥解密的过程。我们来证明一下这个流程，从前面我们得知P<sub>B</sub> =d<sub>B</sub> * G，C1 = k * G。实际上我们只需证明，k * d<sub>B</sub> * G =d<sub>B</sub> * k * G ，等式的成立是显而易见的。而后的C3主要是为了验证消息的正确性。

### ECDHE-SM2
从ECDHE-SM2这个cipher所在文档的名称就能看出来，它是官方想要主力推荐的cipher，相对与ECC-SM2以及标准ECDSA和RSA相关cipher来说，该cipher会更加的安全，然而从来没有真正的银弹，安全的代价是繁琐的流程以及更多的计算开销，甚至还需要client也满足一定要求，因此，现有的互联网公司几乎都在尽力避开这个算法套件，360浏览器干脆直接不支持这个套件了。在了解这个cipher的流程前，我们还是照例回顾下标准的ECDHE算法握手流程：

![](/images/self-drawn/gm-key-exchange/ecdhe.png)

而对于ECDHE-SM2这个cipher来说，虽然流程看起来繁琐了很多，但某些本质还是换汤不换药的，我们来看下这个cipher的流程，从流程图就能感受到它的繁琐：

![](/images/self-drawn/gm-key-exchange/ecdhe-sm2.png)

标准文档的流程图中并没有对于关键的密钥导出步骤进行说明，这里补充一下，大家关注下用户A的第七步和用户B的第六步，实际的计算流程如下(由于文档的限制，带有上标'-'的x1和x2就以x1和x2替代了，这个替换不会影响理解):

- 用户A：计算U = \[h * t<sub>A</sub>\](P<sub>B</sub> + x<sub>2</sub> * R<sub>B</sub>) = (x<sub>U</sub>,y<sub>U</sub>)，其中t<sub>A</sub> = (d<sub>A</sub> + x<sub>1</sub> * r<sub>A</sub>)，d<sub>A</sub>为A的私钥，P<sub>B</sub>为B的公钥
- 用户B：计算V = \[h * t<sub>B</sub>\[(P<sub>A</sub> + x<sub>1</sub> * R<sub>A</sub>) = (x<sub>V</sub>,y<sub>V</sub>)，其中t<sub>B</sub> = (d<sub>B</sub> + x<sub>2</sub> * r<sub>B</sub>)，d<sub>B</sub>为B的私钥，P<sub>A</sub>为A的公钥

这里的"[]"还是表示椭圆曲线乘法，而x1和x2都是带有上标'-'的。

从流程图我们可以看到，用户A和用户B若要保证导出的密钥KA与KB一致，只需要保证U，V相等就行了，我们来证明一下U和V为什么相等，这里会多一点数学式子，但都是很简单的：

![](/images/self-drawn/gm-key-exchange/ecdhe-formular.png)

对于红框内的式子，这是一个看似显然，但实际很不显然的式子，我们很轻易就能够验证：(7 % 3) * 5 和(5 % 3) * 7是截然不同的结果，那么为什么U=V这个式子还能成立呢？这里需要对这个mod n进行说明，n表示椭圆曲线的阶，阶的定义为：在椭圆曲线域中，对于确定的基点G，当满足[K] * G = 0这个式子时，K的最小值称作椭圆的阶n。简单来说[n]*G=0，而由于椭圆曲线群满足分配率(即[a+b]G = [a]G + [b]G)，我们可以得到，对于任意数N有：[N] * G = [N mod n] * G (证明:N = k*n + (N mod n)) ，于是，上面的式子变为：

![](/images/self-drawn/gm-key-exchange/echde-prove.png)

这里的阐述相对啰嗦了一些，主要是希望没有接触过椭圆曲线理论的同学也能看的没有任何心智负担，流程图中后续的步骤10都是对于消息正确的验证，也就是做了一个hash然后对比结果，这里就不赘述了。

## 从算法流程看国密的问题
单从cipher的层面，我们也能看出不少国密的问题来，首先是ECC-SM2这个cipher，我们前面提到了，ECC-SM2这个cipher的握手流程和RSA的握手流程是一样的，回顾一下前面的流程图我们可以发现，client依赖server的证书才能够进行公钥加密，这意味着至少要2个RTT才能够完成握手，而也就是为什么现有的TLS1.3协议标准中废除了RSA的握手过程的原因，当然，聪明的你也肯定能从标准ECDHE密钥交换流程中看懂为什么TLS1.3能够实现1RTT会话建连。

看起来ECC-SM2这个cipher和时代已经有一些脱节，不过值得庆幸的是，从ECDHE-SM2这个cipher的流程图我们可以发现，虽然步骤繁琐，但取消掉步骤10这个可选项，我们也是可以实现1RTT握手的。然而ECDHE-SM2这个cipher本身的问题比ECC-SM2还要严重，严重到甚至完全不可接受的地步。首先就是相对于标准ECDHE算法来说超高的计算开销，从流程图我们可以发现，这个开销不光是加在server端，client端也难以逃避，而对于移动终端来说，如此高额的计算开销带来的功耗，时延，发热，卡顿等问题，都十分令人头疼。而更加严重的是，算法要求client必须持有证书，从算法层面我们来看，几个公式的变换依赖的是双方使用相同的椭圆曲线的基点G，这也就意味着，client的证书必须是和server一样的证书，而且必须是国密证书，同时也必须是同一条曲线同一个基点，其扩展性令人担忧。从应用层面来看，在client预埋证书带来的存储开销，以及通信过程传输证书带来的额外开销就已经不太能令人接受了，又何况本身推进所有client持有证书也是一个难题，各种浏览器，特别是Firefox，chrome之类，他们很大概率不会接受持有证书的方案，这也就是为什么这个cipher在互联网公司中几乎没有任何应用场景的原因。